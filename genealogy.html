<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Genealogy</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {margin:0;overflow:hidden;font-family:Arial,sans-serif;background:#f0f0f0;}
#layout {display:flex;height:100vh;}
#canvas {flex:1;background:#fafafa;}
#sidebar {width:220px;background:#222;color:white;padding:8px;overflow-y:auto;}
button {width:100%;margin:6px 0;padding:8px;cursor:pointer;}
.tab {padding:6px;background:#444;margin:4px 0;cursor:pointer;}
.tab.active {background:#666;}
text {user-select:none;cursor:pointer;}
.tooltip {position:absolute;background:white;color:black;padding:2px 5px;border-radius:3px;font-size:12px;display:none;pointer-events:none;z-index:1000;white-space:nowrap;}
#popup {position:absolute;display:none;background:#fff;border:1px solid #999;padding:8px;border-radius:4px;z-index:1000;}
#popup input {width:100%;margin:4px 0;}
#popup button {margin-top:4px;}
</style>
</head>
<body>

<div id="layout">
<svg id="canvas"></svg>
<div id="sidebar">
<button onclick="newTree()">âž• New</button>
<button onclick="undo()">â†© Undo</button>
<button onclick="saveTree()">ðŸ’¾ Save</button>
<button onclick="loadTree()">ðŸ“‚ Load</button>
<hr>
<div id="tabs"></div>
</div>
</div>

<div id="popup">
<label>Rename (blank to delete)</label>
<input type="text" id="renameInput">
<label>Add child (blank for none)</label>
<input type="text" id="childInput">
<label>Color</label>
<input type="color" id="colorInput">
<button onclick="applyPopup()">Apply</button>
<button onclick="viewPerspective()">View in this perspective</button>
<button onclick="closePopup()">Cancel</button>
</div>

<div class="tooltip" id="tooltip"></div>

<script>
const svg=document.getElementById("canvas");
const NS="http://www.w3.org/2000/svg";
const view=document.createElementNS(NS,"g");
svg.appendChild(view);
const tooltip=document.getElementById("tooltip");

let trees=[],active=0,scale=1,tx=0,ty=0,undoStack=[],popupNode=null;

const popup=document.getElementById("popup");
const renameInput=document.getElementById("renameInput");
const childInput=document.getElementById("childInput");
const colorInput=document.getElementById("colorInput");

// Create root node
function rootNode(){
  return {name:"Root Person",children:[],depth:0,hue:200,light:70,order:0};
}
newTree();

/* ---------- TABS ---------- */
function newTree(){
  trees.push({name:"Root Person",root:rootNode()});
  active=trees.length-1;
  pushUndo();
  resetView();
  updateTabs();
  draw();
}

function updateTabs(){
  const t=document.getElementById("tabs");
  t.innerHTML="";
  trees.forEach((tr,i)=>{
    const d=document.createElement("div");
    d.className="tab"+(i===active?" active":"");
    d.textContent=tr.name;
    d.onclick=()=>{active=i;draw();updateTabs();};
    d.ondblclick=()=>{
      const n=prompt("Rename tree (blank deletes):",tr.name);
      if(n===null) return;
      if(n===""){trees.splice(i,1);active=Math.max(0,active-1);}
      else tr.name=n;
      updateTabs(); draw();
    };
    t.appendChild(d);
  });
}

/* ---------- DRAW ---------- */
function draw(){
  view.innerHTML="";
  const cx=svg.clientWidth/2;
  const cy=svg.clientHeight/2;
  drawNode(trees[active].root,cx,cy,-Math.PI/2,3*Math.PI/2,60);
}

function drawNode(node,cx,cy,a1,a2,r){
  if(node.depth===0) drawCircle(cx,cy,r,node);
  if(!node.children.length) return;
  const slice=(a2-a1)/node.children.length;
  const r2=r+90;
  node.children.sort((a,b)=>a.order-b.order);
  node.children.forEach((ch,i)=>{
    const s=a1+i*slice;
    const e=s+slice;
    drawWedge(cx,cy,r,r2,s,e,ch);
    drawNode(ch,cx,cy,s,e,r2);
  });
}

function drawCircle(x,y,r,node){
  const c=document.createElementNS(NS,"circle");
  c.setAttribute("cx",x);
  c.setAttribute("cy",y);
  c.setAttribute("r",r);
  c.setAttribute("fill",hslToHex(node.hue,node.light));
  view.appendChild(c);
  drawLabel(node,x,y,r*0.7,node.depth,0,r);
  c.addEventListener("click",e=>{e.stopPropagation();showPopup(node,e.clientX,e.clientY);});
}

function drawWedge(cx,cy,r1,r2,a1,a2,node){
  const p=(r,a)=>[cx+Math.cos(a)*r,cy+Math.sin(a)*r];
  const [x1,y1]=p(r1,a1),[x2,y2]=p(r1,a2),
        [x3,y3]=p(r2,a2),[x4,y4]=p(r2,a1);
  const path=document.createElementNS(NS,"path");
  path.setAttribute("d",
    `M${x1} ${y1} A${r1} ${r1} 0 0 1 ${x2} ${y2} L${x3} ${y3} A${r2} ${r2} 0 0 0 ${x4} ${y4} Z`
  );
  path.setAttribute("fill",hslToHex(node.hue,node.light));
  view.appendChild(path);
  path.addEventListener("click",e=>{e.stopPropagation();showPopup(node,e.clientX,e.clientY);});
  const ang=(a1+a2)/2;
  drawLabel(node,cx+Math.cos(ang)*(r1+(r2-r1)/2),cy+Math.sin(ang)*(r1+(r2-r1)/2),(r2-r1)*0.55,node.depth,ang,r1+(r2-r1)/2);
}

/* ---------- LABELS ---------- */
function drawLabel(node,x,y,max,depth,angle,radius){
  const t=document.createElementNS(NS,"text");
  t.setAttribute("x",x);
  t.setAttribute("y",y);
  t.setAttribute("text-anchor","middle");
  t.setAttribute("dominant-baseline","middle");
  t.textContent=node.name;
  view.appendChild(t);
  let size=Math.min(16,max);
  t.setAttribute("font-size",size);
  t.addEventListener("mouseenter",e=>{
    tooltip.style.display="block";
    tooltip.textContent=node.name;
    tooltip.style.left=e.clientX+10+"px";
    tooltip.style.top=e.clientY+10+"px";
    tooltip.style.background=hslToHex(node.hue,node.light);
    tooltip.style.color="white";
    tooltip.style.padding="2px 4px";
  });
  t.addEventListener("mouseleave",e=>{tooltip.style.display="none";});
  t.addEventListener("click",e=>{e.stopPropagation();showPopup(node,e.clientX,e.clientY);});
}

/* ---------- POPUP ---------- */
function showPopup(node,x,y){
  popupNode=node;
  renameInput.value=node.name;
  childInput.value="";
  colorInput.value=hslToHex(node.hue,node.light);
  popup.style.left=Math.min(x+5,window.innerWidth-220)+"px";
  popup.style.top=Math.min(y+5,window.innerHeight-150)+"px";
  popup.style.display="block";
  childInput.focus();
}

function closePopup(){popup.style.display="none";popupNode=null;}

function applyPopup(){
  if(!popupNode) return;
  pushUndo();

  const newName=renameInput.value.trim();
  if(newName===""){
    if(popupNode.depth>0) deleteChild(popupNode);
    closePopup(); draw(); return;
  }
  popupNode.name=newName;

  // Adjust color only if it's a child of root
  if(colorInput.value && popupNode.depth===1){
    const hsl=colorInput.value;
    popupNode.hue=parseInt(colorInput.value.slice(1,3),16)/255*360;
    // update shades of grandchildren
    popupNode.children.forEach((c,i)=>{
      c.hue=popupNode.hue;
      c.light=Math.min(90,c.light);
    });
  }

  // add child
  const childName=childInput.value.trim();
  if(childName!==""){
    const newChild={
      name:childName,
      children:[],
      depth:popupNode.depth+1,
      hue:(popupNode.depth===0 ? (popupNode.children.length*137)%360 : popupNode.hue),
      light:(popupNode.depth===0 ? 70 : Math.min(90,popupNode.light+10*(popupNode.children.length+1))),
      order:popupNode.children.length
    };
    popupNode.children.push(newChild);
  }

  closePopup(); draw();
}

// Press Enter to apply popup
renameInput.addEventListener("keydown",e=>{if(e.key==="Enter") applyPopup();});
childInput.addEventListener("keydown",e=>{if(e.key==="Enter") applyPopup();});
colorInput.addEventListener("keydown",e=>{if(e.key==="Enter") applyPopup();});

/* ---------- VIEW PERSPECTIVE ---------- */
function viewPerspective(){
  if(!popupNode) return;
  function cloneSubtree(node,depth=0){
    const cloned={name:node.name,depth:depth,hue:node.hue,light:node.light,children:[],order:0};
    cloned.children=node.children.map((c,i)=>{
      const ch=cloneSubtree(c,depth+1);
      if(depth===0) ch.hue=(i*137)%360;
      return ch;
    });
    return cloned;
  }
  trees.push({name:popupNode.name+"'s view",root:cloneSubtree(popupNode)});
  active=trees.length-1;
  resetView(); updateTabs(); draw();
}

/* ---------- DELETE CHILD ---------- */
function deleteChild(node){
  function recurse(parent){
    parent.children=parent.children.filter(c=>c!==node);
    parent.children.forEach(recurse);
  }
  recurse(trees[active].root);
}

/* ---------- UNDO ---------- */
function pushUndo(){undoStack.push(JSON.stringify(trees[active])); if(undoStack.length>20) undoStack.shift();}
function undo(){if(undoStack.length===0) return; trees[active]=JSON.parse(undoStack.pop()); draw();}
window.addEventListener("keydown",e=>{if(e.ctrlKey&&e.key==="z") undo();});

/* ---------- ZOOM & PAN ---------- */
svg.addEventListener("wheel",e=>{
  e.preventDefault();
  const pt=svg.createSVGPoint(); pt.x=e.clientX; pt.y=e.clientY;
  const before=pt.matrixTransform(view.getCTM().inverse());
  const z=e.deltaY<0?1.1:0.9;
  scale*=z;
  tx+=before.x*(1-z); ty+=before.y*(1-z);
  updateTransform();
});
svg.addEventListener("mousedown",e=>{
  if(e.button!==1) return;
  let x=e.clientX,y=e.clientY;
  window.onmousemove=ev=>{tx+=ev.clientX-x;ty+=ev.clientY-y;x=ev.clientX;y=ev.clientY;updateTransform();};
  window.onmouseup=()=>window.onmousemove=null;
});
function updateTransform(){view.setAttribute("transform",`translate(${tx},${ty}) scale(${scale})`);}
function resetView(){scale=1;tx=0;ty=0;updateTransform();}
svg.addEventListener("click",e=>{if(!popup.contains(e.target)) closePopup();});

/* ---------- SAVE / LOAD ---------- */
function saveTree(){const a=document.createElement("a"); a.href=URL.createObjectURL(new Blob([JSON.stringify(trees[active],null,2)],{type:"application/json"})); a.download="genealogy.json"; a.click();}
function loadTree(){const i=document.createElement("input"); i.type="file"; i.accept=".json"; i.onchange=e=>{const r=new FileReader(); r.onload=()=>{trees.push(JSON.parse(r.result)); active=trees.length-1; resetView(); updateTabs(); draw();}; r.readAsText(e.target.files[0]);}; i.click();}

/* ---------- COLOR UTILS ---------- */
function hslToHex(h,l){
  let c=1, x=0, m=l/100-0.5; // simplified for visualization
  let rgb=[0,0,255];
  return `hsl(${h},70%,${l}%)`;
}
</script>
</body>
</html>
