<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Genealogy</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {margin:0;overflow:hidden;font-family:Arial,sans-serif;background:#f0f0f0;}
#layout {display:flex;height:100vh;}
#canvas {flex:1;background:#fafafa;}
#sidebar {width:220px;background:#222;color:white;padding:8px;overflow-y:auto;}
button {width:100%;margin:6px 0;padding:8px;cursor:pointer;}
.tab {padding:6px;background:#444;margin:4px 0;cursor:pointer;}
.tab.active {background:#666;}
text {user-select:none;cursor:pointer;}
.tooltip {position:absolute;background:white;color:black;padding:2px 5px;border-radius:3px;font-size:12px;display:none;pointer-events:none;z-index:1000;white-space:nowrap;}
#popup {position:absolute;display:none;background:#fff;border:1px solid #999;padding:8px;border-radius:4px;z-index:1000;}
#popup input {width:100%;margin:4px 0;}
#popup button {margin-top:4px;}
</style>
</head>
<body>

<div id="layout">
<svg id="canvas"></svg>
<div id="sidebar">
<button onclick="newTree()">âž• New</button>
<button onclick="undo()">â†© Undo</button>
<button onclick="saveTree()">ðŸ’¾ Save</button>
<button onclick="loadTree()">ðŸ“‚ Load</button>
<hr>
<div id="tabs"></div>
</div>
</div>

<div id="popup">
<label>Rename (blank to delete)</label>
<input type="text" id="renameInput">
<label>Add child (blank for none)</label>
<input type="text" id="childInput">
<label>Color</label>
<input type="color" id="colorInput">
<button onclick="applyPopup()">Apply</button>
<button onclick="viewPerspective()">View in this perspective</button>
<button onclick="closePopup()">Cancel</button>
</div>

<div class="tooltip" id="tooltip"></div>

<script>
const svg = document.getElementById("canvas");
const NS = "http://www.w3.org/2000/svg";
const view = document.createElementNS(NS,"g");
svg.appendChild(view);
const tooltip = document.getElementById("tooltip");

let trees=[], active=0;
let scale=1, tx=0, ty=0;
let undoStack=[];
let popupNode=null;

const popup=document.getElementById("popup");
const renameInput=document.getElementById("renameInput");
const childInput=document.getElementById("childInput");
const colorInput=document.getElementById("colorInput");

function rootNode() {
  return {name:"Root Person", children:[], depth:0, color:"#66aaff", order:0};
}

newTree();

/* TABS */
function newTree(){
  trees.push({name:"Root Person", root:rootNode()});
  active=trees.length-1;
  pushUndo();
  resetView();
  updateTabs();
  draw();
}

function updateTabs(){
  const t=document.getElementById("tabs");
  t.innerHTML="";
  trees.forEach((tr,i)=>{
    const d=document.createElement("div");
    d.className="tab"+(i===active?" active":"");
    d.textContent=tr.name;
    d.onclick=()=>{active=i;draw();updateTabs();};
    d.ondblclick=()=>{
      const n=prompt("Rename tree (blank deletes):",tr.name);
      if(n===null) return;
      if(n===""){trees.splice(i,1);active=Math.max(0,active-1);}
      else tr.name=n;
      updateTabs(); draw();
    };
    t.appendChild(d);
  });
}

/* DRAW */
function draw(){
  view.innerHTML="";
  const cx=svg.clientWidth/2;
  const cy=svg.clientHeight/2;
  drawNode(trees[active].root,cx,cy,-Math.PI/2,3*Math.PI/2,60);
}

function drawNode(node,cx,cy,a1,a2,r){
  if(node.depth===0) drawCircle(cx,cy,r,node);
  if(!node.children.length) return;
  const slice=(a2-a1)/node.children.length;
  const r2=r+90;
  node.children.sort((a,b)=>a.order-b.order);
  node.children.forEach((ch,i)=>{
    const s=a1+i*slice;
    const e=s+slice;
    drawWedge(cx,cy,r,r2,s,e,ch);
    drawNode(ch,cx,cy,s,e,r2);
  });
}

function drawCircle(x,y,r,node){
  const c=document.createElementNS(NS,"circle");
  c.setAttribute("cx",x);
  c.setAttribute("cy",y);
  c.setAttribute("r",r);
  c.setAttribute("fill",node.color);
  view.appendChild(c);
  drawLabel(node,x,y,r*0.7,node.depth,0,r);
  c.addEventListener("click",e=>{e.stopPropagation();showPopup(node,e.clientX,e.clientY);});
}

function drawWedge(cx,cy,r1,r2,a1,a2,node){
  const p=(r,a)=>[cx+Math.cos(a)*r,cy+Math.sin(a)*r];
  const [x1,y1]=p(r1,a1),[x2,y2]=p(r1,a2),
        [x3,y3]=p(r2,a2),[x4,y4]=p(r2,a1);
  const path=document.createElementNS(NS,"path");
  path.setAttribute("d",
    `M${x1} ${y1} A${r1} ${r1} 0 0 1 ${x2} ${y2} L${x3} ${y3} A${r2} ${r2} 0 0 0 ${x4} ${y4} Z`
  );
  path.setAttribute("fill",node.color);
  view.appendChild(path);
  path.addEventListener("click",e=>{e.stopPropagation();showPopup(node,e.clientX,e.clientY);});
  const ang=(a1+a2)/2;
  drawLabel(node,cx+Math.cos(ang)*(r1+(r2-r1)/2),cy+Math.sin(ang)*(r1+(r2-r1)/2),(r2-r1)*0.55,node.depth,ang,r1+(r2-r1)/2);
}

function drawLabel(node,x,y,max,depth,angle,radius){
  const t=document.createElementNS(NS,"text");
  t.setAttribute("x",x);
  t.setAttribute("y",y);
  t.setAttribute("text-anchor","middle");
  t.setAttribute("dominant-baseline","middle");
  t.textContent=node.name;
  view.appendChild(t);
  let size=Math.min(16,max);
  t.setAttribute("font-size",size);
  t.addEventListener("mouseenter",e=>{
    tooltip.style.display="block";
    tooltip.textContent=node.name;
    tooltip.style.left=e.clientX+10+"px";
    tooltip.style.top=e.clientY+10+"px";
    tooltip.style.background=node.color;
    tooltip.style.color="white";
    tooltip.style.padding="2px 4px";
  });
  t.addEventListener("mouseleave",e=>{tooltip.style.display="none";});
  t.addEventListener("click",e=>{e.stopPropagation();showPopup(node,e.clientX,e.clientY);});
}

/* POPUP */
function showPopup(node,x,y){
  popupNode=node;
  renameInput.value=node.name;
  childInput.value="";
  colorInput.value=node.color;
  popup.style.left=x+5+"px";
  popup.style.top=y+5+"px";
  popup.style.display="block";
  childInput.focus();
}

function closePopup(){popup.style.display="none";popupNode=null;}

function applyPopup(){
  if(!popupNode) return;
  pushUndo();

  // rename
  const newName=renameInput.value.trim();
  if(newName===""){
    if(popupNode.depth>0) deleteChild(popupNode);
    closePopup(); draw(); return;
  }
  popupNode.name=newName;

  // change color only if user clicked color
  if(colorInput.value) popupNode.color=colorInput.value;

  // add child
  const childName=childInput.value.trim();
  if(childName!==""){
    const newChild={
      name:childName,
      children:[],
      depth:popupNode.depth+1,
      color:popupNode.depth===0?`hsl(${(popupNode.children.length*137)%360},70%,70%)`:popupNode.color,
      order:popupNode.children.length
    };
    popupNode.children.push(newChild);
  }

  closePopup(); draw();
}

renameInput.addEventListener("keydown",e=>{if(e.key==="Enter") applyPopup();});
childInput.addEventListener("keydown",e=>{if(e.key==="Enter") applyPopup();});
colorInput.addEventListener("keydown",e=>{if(e.key==="Enter") applyPopup();});

/* VIEW PERSPECTIVE */
function viewPerspective(){
  if(!popupNode) return;
  function cloneSubtree(node,depth=0){
    const cloned={name:node.name, depth:depth, color:node.color, children:[], order:0};
    cloned.children=node.children.map((c,i)=>{
      const ch=cloneSubtree(c,depth+1);
      if(depth===0) ch.color=`hsl(${i*137},70%,70%)`; // root's children unique colors
      return ch;
    });
    return cloned;
  }
  trees.push({name:popupNode.name+"'s view", root:cloneSubtree(popupNode)});
  active=trees.length-1;
  resetView(); updateTabs(); draw();
}

/* DELETE CHILD */
function deleteChild(node){
  function recurse(parent){
    parent.children=parent.children.filter(c=>c!==node);
    parent.children.forEach(recurse);
  }
  recurse(trees[active].root);
}

/* UNDO */
function pushUndo(){undoStack.push(JSON.stringify(trees[active])); if(undoStack.length>20) undoStack.shift();}
function undo(){if(undoStack.length===0) return; trees[active]=JSON.parse(undoStack.pop()); draw();}
window.addEventListener("keydown",e=>{if(e.ctrlKey&&e.key==="z") undo();});

/* ZOOM & PAN */
svg.addEventListener("wheel",e=>{
  e.preventDefault();
  const pt=svg.createSVGPoint(); pt.x=e.clientX; pt.y=e.clientY;
  const before=pt.matrixTransform(view.getCTM().inverse());
  const z=e.deltaY<0?1.1:0.9;
  scale*=z;
  tx+=before.x*(1-z); ty+=before.y*(1-z);
  updateTransform();
});
svg.addEventListener("mousedown",e=>{
  if(e.button!==1) return;
  let x=e.clientX,y=e.clientY;
  window.onmousemove=ev=>{tx+=ev.clientX-x;ty+=ev.clientY-y;x=ev.clientX;y=ev.clientY;updateTransform();};
  window.onmouseup=()=>window.onmousemove=null;
});
function updateTransform(){view.setAttribute("transform",`translate(${tx},${ty}) scale(${scale})`);}
function resetView(){scale=1;tx=0;ty=0;updateTransform();}
svg.addEventListener("click",e=>{if(!popup.contains(e.target)) closePopup();});

/* SAVE / LOAD */
function saveTree(){const a=document.createElement("a"); a.href=URL.createObjectURL(new Blob([JSON.stringify(trees[active],null,2)],{type:"application/json"})); a.download="genealogy.json"; a.click();}
function loadTree(){const i=document.createElement("input"); i.type="file"; i.accept=".json"; i.onchange=e=>{const r=new FileReader(); r.onload=()=>{trees.push(JSON.parse(r.result)); active=trees.length-1; resetView(); updateTabs(); draw();}; r.readAsText(e.target.files[0]);}; i.click();}
</script>
</body>
</html>
